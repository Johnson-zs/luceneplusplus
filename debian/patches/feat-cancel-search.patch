Index: luceneplusplus/include/lucene++/SearchCancellation.h
===================================================================
--- /dev/null
+++ luceneplusplus/include/lucene++/SearchCancellation.h
@@ -0,0 +1,85 @@
+/////////////////////////////////////////////////////////////////////////////
+// Copyright (c) 2009-2014 Alan Wright. All rights reserved.
+// Distributable under the terms of either the Apache License (Version 2.0)
+// or the GNU Lesser General Public License.
+//
+// Extended by UnionTech Software Technology Co., Ltd. (2024)
+// Added search cancellation support for responsive user interactions
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef SEARCHCANCELLATION_H
+#define SEARCHCANCELLATION_H
+
+#include "LuceneTypes.h"
+#include <atomic>
+
+namespace Lucene {
+
+/**
+ * @brief Global search cancellation context using thread-local storage
+ *
+ * This class provides a mechanism to cancel long-running searches from external code.
+ * It uses thread-local storage to ensure thread safety and isolation.
+ *
+ * Usage:
+ * 1. Before search: SearchCancellation::setFlag(&cancelFlag)
+ * 2. During search: SearchCancellation::shouldCancel() checks the flag
+ * 3. After search: SearchCancellation::clear() cleans up
+ *
+ * Thread-safety: Each thread has its own independent cancellation flag.
+ */
+class LPPAPI SearchCancellation {
+public:
+    /**
+     * @brief Set cancellation flag for current thread
+     * @param flag Pointer to atomic boolean cancellation flag
+     */
+    static void setFlag(std::atomic<bool>* flag);
+
+    /**
+     * @brief Get current thread's cancellation flag
+     * @return Pointer to cancellation flag, or nullptr if not set
+     */
+    static std::atomic<bool>* getFlag();
+
+    /**
+     * @brief Clear current thread's cancellation flag
+     */
+    static void clear();
+
+    /**
+     * @brief Check if current thread should cancel (convenience method)
+     * @return true if should cancel, false otherwise
+     *
+     * This method is called frequently in tight loops (e.g., ExactPhraseScorer::phraseFreq),
+     * so it uses memory_order_relaxed for minimal performance impact.
+     */
+    static bool shouldCancel();
+};
+
+/**
+ * @brief RAII guard for automatic cancellation flag management
+ *
+ * Usage:
+ * @code
+ * void performSearch() {
+ *     SearchCancellationGuard guard(&m_cancelled);
+ *     // ... perform search ...
+ * } // Automatic cleanup on scope exit
+ * @endcode
+ */
+class LPPAPI SearchCancellationGuard {
+public:
+    explicit SearchCancellationGuard(std::atomic<bool>* flag);
+    ~SearchCancellationGuard();
+
+    // Non-copyable and non-movable
+    SearchCancellationGuard(const SearchCancellationGuard&) = delete;
+    SearchCancellationGuard& operator=(const SearchCancellationGuard&) = delete;
+    SearchCancellationGuard(SearchCancellationGuard&&) = delete;
+    SearchCancellationGuard& operator=(SearchCancellationGuard&&) = delete;
+};
+
+}
+
+#endif // SEARCHCANCELLATION_H
Index: luceneplusplus/src/core/search/ExactPhraseScorer.cpp
===================================================================
--- luceneplusplus.orig/src/core/search/ExactPhraseScorer.cpp
+++ luceneplusplus/src/core/search/ExactPhraseScorer.cpp
@@ -8,6 +8,7 @@
 #include "ExactPhraseScorer.h"
 #include "PhrasePositions.h"
 #include "PhraseQueue.h"
+#include "SearchCancellation.h"
 
 namespace Lucene {
 
@@ -29,9 +30,23 @@ double ExactPhraseScorer::phraseFreq() {
     // For counting how many times the exact phrase is found in current document, just count how many
     // times all PhrasePosition's have exactly the same position.
     int32_t freq = 0;
+
+    // Cancellation check: balance between performance and responsiveness
+    // Check every N iterations to allow user cancellation of long-running phrase searches
+    const int32_t CANCELLATION_CHECK_INTERVAL = 1000;
+    int32_t iterationCount = 0;
+
     do {
         while (first->position < last->position) { // scan forward in first
             do {
+                // Periodically check for cancellation
+                if (++iterationCount % CANCELLATION_CHECK_INTERVAL == 0) {
+                    if (SearchCancellation::shouldCancel()) {
+                        // Throw exception to interrupt search
+                        boost::throw_exception(RuntimeException(L"Search cancelled by user"));
+                    }
+                }
+
                 if (!first->nextPosition()) {
                     return freq;
                 }
Index: luceneplusplus/src/core/search/SearchCancellation.cpp
===================================================================
--- /dev/null
+++ luceneplusplus/src/core/search/SearchCancellation.cpp
@@ -0,0 +1,49 @@
+/////////////////////////////////////////////////////////////////////////////
+// Copyright (c) 2009-2014 Alan Wright. All rights reserved.
+// Distributable under the terms of either the Apache License (Version 2.0)
+// or the GNU Lesser General Public License.
+//
+// Extended by UnionTech Software Technology Co., Ltd. (2024)
+// Added search cancellation support for responsive user interactions
+/////////////////////////////////////////////////////////////////////////////
+
+#include "LuceneInc.h"
+#include "SearchCancellation.h"
+
+namespace Lucene {
+
+// Thread-local storage for cancellation flag
+// Each thread has its own independent flag pointer
+static thread_local std::atomic<bool>* g_threadCancellationFlag = nullptr;
+
+void SearchCancellation::setFlag(std::atomic<bool>* flag) {
+    g_threadCancellationFlag = flag;
+}
+
+std::atomic<bool>* SearchCancellation::getFlag() {
+    return g_threadCancellationFlag;
+}
+
+void SearchCancellation::clear() {
+    g_threadCancellationFlag = nullptr;
+}
+
+bool SearchCancellation::shouldCancel() {
+    if (g_threadCancellationFlag) {
+        // Use memory_order_relaxed for minimal performance impact
+        // Cancellation is a one-way operation (false -> true), so we don't need
+        // strict synchronization guarantees
+        return g_threadCancellationFlag->load(std::memory_order_relaxed);
+    }
+    return false;
+}
+
+SearchCancellationGuard::SearchCancellationGuard(std::atomic<bool>* flag) {
+    SearchCancellation::setFlag(flag);
+}
+
+SearchCancellationGuard::~SearchCancellationGuard() {
+    SearchCancellation::clear();
+}
+
+}
Index: luceneplusplus/src/core/search/SloppyPhraseScorer.cpp
===================================================================
--- luceneplusplus.orig/src/core/search/SloppyPhraseScorer.cpp
+++ luceneplusplus/src/core/search/SloppyPhraseScorer.cpp
@@ -9,6 +9,7 @@
 #include "PhrasePositions.h"
 #include "PhraseQueue.h"
 #include "Similarity.h"
+#include "SearchCancellation.h"
 
 namespace Lucene {
 
@@ -25,7 +26,19 @@ double SloppyPhraseScorer::phraseFreq()
 
     double freq = 0.0;
     bool done = (end < 0);
+
+    // Cancellation check: same as ExactPhraseScorer
+    const int32_t CANCELLATION_CHECK_INTERVAL = 1000;
+    int32_t iterationCount = 0;
+
     while (!done) {
+        // Periodically check for cancellation (outer loop)
+        if (++iterationCount % CANCELLATION_CHECK_INTERVAL == 0) {
+            if (SearchCancellation::shouldCancel()) {
+                boost::throw_exception(RuntimeException(L"Search cancelled by user"));
+            }
+        }
+
         PhrasePositionsPtr pp(pq->pop());
         int32_t start = pp->position;
         int32_t next = pq->top()->position;
